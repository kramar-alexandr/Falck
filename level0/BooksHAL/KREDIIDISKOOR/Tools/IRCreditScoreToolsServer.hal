external function Integer SecondsToTime(LongInt,var Time);
external procedure GetBankruptcyRiskScoreForOrg(string,record ServiceCacheVc,var boolean,var val);
external function boolean ValidCreditScore(val);
external function boolean IRServiceActivated(string);
external function boolean CredScoreCanExist(record CUVc); //cust KB 18.04.2018
external updating procedure StoreCUServiceUsage(date,string,Integer,string,Integer,Integer);//cust, ts - 2018/04, e-service statistic

global
function val GetCreditScoreFor(string regNr1)
begin
  val res;
  record IRSuppVc IRSuppr;

  res = blankval;
  IRSuppr.RegNr1 = Trim(regNr1);
  if(ReadFirstMain(IRSuppr,1,true)) then begin
    res = IRSuppr.CreditScore;
  end;
  GetCreditScoreFor = res;
  return
end;

global
function date GetCreditScoreDateFor(string regNr1)
begin
  date res;
  record IRSuppVc IRSuppr;
  
  IRSuppr.RegNr1 = Trim(regNr1);
  if(ReadFirstMain(IRSuppr,1,true)) then begin
    res = IRSuppr.CreditScoreUpdDate;
  end;
  GetCreditScoreDateFor = res;
  return
end;

global
procedure GetCredScoreAndDateFor(string regNr1, var val score, var date updDate)
begin
  if (IRServiceActivated("FINDCREDITSCORE")) then begin
    score = GetCreditScoreFor(regNr1);
    updDate = GetCreditScoreDateFor(regNr1);
  end;
  return;
end;

global
updating procedure UpdateCreditScoreRecord(var record IRSuppVc IRSuppr, val newCreditScore)
begin
  record IRSuppVc oldIRsuppr;

  RecordCopy(oldIRsuppr,IRSuppr);
  IRSuppr.CreditScore = newCreditScore;
  IRSuppr.CreditScoreUpdDate = CurrentDate;
  RecordUpdate(oldIRsuppr,IRSuppr,false);
  return;
end;

global
updating procedure CreateCreditScoreRecord(string CURegNr1,val CreditScore)
begin
  record IRSuppVc IRSuppr;

  RecordNew(IRSuppr);
  IRSuppr.RegNr1 = Trim(CURegNr1);
  IRSuppr.CreditScore = creditScore;
  IRSuppr.CreditScoreUpdDate = CurrentDate;
  RecordInsert(IRSuppr,false);
  return;
end;

global
updating procedure ResetIRSetBlock(record IRSetBlock IRSetr)
begin
  IRSetr.UpdInterruptedFlag = 0; //first reset the las err flag if it was set
  BlockStore(IRSetr);
  return;
end;

global
updating procedure ResetIRCredScoreCUSetBlock(record IRSetBlock IRSetr,string CUCode,date sdate)
begin
  IRSetr.UpdInterruptedFlag = 1; //will indicate that interrupt happened during update
  IRSetr.FailedCredScoreCU = CUCode;
  IRSetr.FailureDate = sdate;
  BlockStore(IRSetr);
  return;
end;

global
procedure GetAllCreditScoresFromIR(var longint count, var string errDescr)
begin
  record CUVc CUr;
  record ServiceCacheVc SCr;
  record IRSuppVc IRSuppr;
  record CYBlock CYb;
  boolean TrHs,errorFlag,newRecord;
  val creditScore;
  record IRSetBlock IRSetr;
  longint recordsLogInterv;
  date blankd;

  recordsLogInterv = 500;
  TrHs = true;
  
  BlockLoad(IRSetr);
  if (nonblank(IRSetr.FailedCredScoreCU) AND IRSetr.FailureDate == CurrentDate) then begin //continue from the failed one
    CUr.Code = IRSetr.FailedCredScoreCU;
  end; //else just try updating all CU again
  qupdating.ResetIRSetBlock(IRSetr);

  SCr.Code = "FINDCREDITSCORE";
  if (ReadFirstMain(SCr,1,true)) then begin
    while (LoopMain(CUr,1,TrHs)) begin
      creditScore = blankval;
      if (TrHs) then begin
        if (CredScoreCanExist(CUr)) then begin
          IRSuppr.RegNr1 = Trim(CUr.RegNr1);
          if(ReadFirstMain(IRSuppr,1,true)) then begin
            newRecord = false;
          end else begin
            newRecord = true;
          end;
          if ((IRSuppr.CreditScoreUpdDate != CurrentDate AND nonblank(IRSuppr.CreditScoreUpdDate)) OR newRecord == true) then begin
            threadremote.GetBankruptcyRiskScoreForOrg(Trim(CUr.RegNr1),SCr,errorFlag,creditScore);
            if (errorFlag) then begin
              qupdating.ResetIRCredScoreCUSetBlock(IRSetr,CUr.Code,CurrentDate);
              errDescr = USetStr(1500009);
              goto LGetAllCreditScoresFromIR;
            end;
          end;
          if (ValidCreditScore(creditScore)) then begin
            if (newRecord) then begin
              queued.CreateCreditScoreRecord(CUr.RegNr1,creditScore);
            end else begin
              queued.UpdateCreditScoreRecord(IRSuppr,creditScore);
            end;
            count = count + 1;
            if(Mod(count,recordsLogInterv) == 0 AND count >= recordsLogInterv) then begin
              LogText(0,"Bankruptcy risk score updated records count: " & count);
            end;
          end;
        end;
      end;
    end;
    //IRSetr.FailedCredScoreCU = ""; //if here, means that all CU updated successufully
    qupdating.ResetIRCredScoreCUSetBlock(IRSetr,"",blankd);
    if (count > 0) then begin
      BlockLoad(CYb);
      queued.StoreCUServiceUsage(CurrentDate,CYb.OrgNr,7,"IRCREDSCORE",1,count);//cust, ts - 2018/04, e-service statistic
    end;
  end;
LGetAllCreditScoresFromIR:;
  Logtext(0, "Records updated" & ": " & count &". " & errDescr); //##cc
  return;
end;

global
function integer CreditScoreToWarninglevel(val creditScore, string recordType, var string msgDispText)
begin
  integer res;
  record CredScoreSettBlock CredScoreSettBlockr;
  row CredScoreSettBlock CredScoreSettBlockrw;
  integer i,rwcnt;
  boolean foundf;

  res = 0;
  foundf = false;
  BlockLoad(CredScoreSettBlockr);
  rwcnt = MatRowCnt(CredScoreSettBlockr);
  if (!ValidCreditScore(creditScore)) then begin
    goto LCreditScoreToWarninglevel;
  end;
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(CredScoreSettBlockr,i,CredScoreSettBlockrw);
    if (creditScore <= CredScoreSettBlockrw.ScoreRangeLastValue) then begin
      foundf = true;
      msgDispText = CredScoreSettBlockrw.DispMessage;
      switch (recordType) begin
        case "IVVc":
          switch (CredScoreSettBlockrw.AllowCreateIVVc)  begin
            case 0: res = 1; //Allow
            case 1: res = 2; //Warn but allow
            case 2: res = 3; //Don't allow
          end;
        case "ORVc":
          switch (CredScoreSettBlockrw.AllowCreateORVc)  begin
            case 0: res = 1; //Allow
            case 1: res = 2; //Warn but allow
            case 2: res = 3; //Don't allow
          end;
        case "SHVc":
          switch (CredScoreSettBlockrw.AllowCreateSHVc)  begin
            case 0: res = 1; //Allow
            case 1: res = 2; //Warn but allow
            case 2: res = 3; //Don't allow
          end;
      end;
      goto LCreditScoreToWarninglevel;
    end;
  end;
  if (foundf == false) then begin
    res = 2;
    msgDispText = USetStr(1500016);
  end;
LCreditScoreToWarninglevel:;
  CreditScoreToWarninglevel = res;
  return
end;

global
procedure GetLatestCreditScoreRemote(record CUVc CUr)
begin
  val creditScore;
  record ServiceCacheVc SCr;
  record IRSuppVc IRSuppr;
  record CYBlock CYb;
  boolean errorFlag;

  SCr.Code = "FINDCREDITSCORE";
  if (ReadFirstMain(SCr,1,true)) then begin
    GetBankruptcyRiskScoreForOrg(CUr.RegNr1,SCr,errorFlag,creditScore);
    if(ValidCreditScore(creditScore)) then begin
      IRSuppr.RegNr1 = Trim(CUr.RegNr1);
      if(ReadFirstMain(IRSuppr,1,true)) then begin
        queued.UpdateCreditScoreRecord(IRSuppr,creditScore);
      end else begin
        queued.CreateCreditScoreRecord(CUr.RegNr1,creditScore);
      end;
    end;
    BlockLoad(CYb);
    queued.StoreCUServiceUsage(CurrentDate,CYb.OrgNr,7,"IRCREDSCORE",1,1);//cust, ts - 2018/04, e-service statistic
  end;    
  return;
end;

global
function time GetCredScoreUpdTimeRemote()
begin
  record CUVc CUr;
  boolean TrHs;
  longint counter,oneRequestTimeMilli,seconds;
  time theTime;

  counter = 0;
  oneRequestTimeMilli = 200;
  TrHs = true;
  while (LoopMain(CUr,1,TrHs)) begin
    if (TrHs) then begin
      if (CredScoreCanExist(CUr)) then begin
        counter = counter + 1;
      end;
    end;
  end;
  counter = counter * oneRequestTimeMilli;
  seconds = counter / 1000;
  SecondsToTime(seconds,theTime);
  GetCredScoreUpdTimeRemote = theTime;
  return;
end;

global
function time GetEMTAKUpdTimeRemote()
begin
  record CUVc CUr;
  boolean TrHs;
  longint counter,oneRequestTimeMilli,seconds;
  time theTime;

  counter = 0;
  oneRequestTimeMilli = 200;
  TrHs = true;
  while (LoopMain(CUr,1,TrHs)) begin
    if (TrHs) then begin
      if (nonblank(CUr.RegNr1)) then begin
        counter = counter + 1;
      end;
    end;
  end;
  counter = counter * oneRequestTimeMilli;
  seconds = counter / 1000;
  SecondsToTime(seconds,theTime);
  GetEMTAKUpdTimeRemote = theTime;
  return;
end;

global
function longint GetWarnLevelForCustomer(string custCode, string recordType, var string dispMsg)
begin
  longint res;
  integer warningLevel;
  val creditScore;
  record CUVc CUr;
  
  res = 0;
  if (IRServiceActivated("FINDCREDITSCORE")) then begin
    if (UserCanAction("IgnoreCreditScores",false) == true) then begin
      goto LSKIP;
    end;
    CUr.Code = custCode;
    if (ReadFirstMain(CUr,1,true)) then begin
      creditScore = GetCreditScoreFor(CUr.RegNr1);
    end;
    if (!ValidCreditScore(creditScore)) then begin
      goto LSKIP;
    end;
    warningLevel = CreditScoreToWarninglevel(creditScore,recordType,dispMsg);
    res = warningLevel;
  end;
LSKIP:;
  GetWarnLevelForCustomer = res;
  return;
end;

global
procedure UpdateCreditScoresMn()
begin
  integer wn;
  longint count;
  string 255 errDescr;

  count = 0;
  if (IRServiceActivated("FINDCREDITSCORE")) then begin
    GetAllCreditScoresFromIR(count,errDescr);
    MessageBox(0, USetStr(1500014) & ": " & count &". " & errDescr);
    wn = CurWindow;
    CloseWindow(wn); 
  end else begin
    MessageBox(1500008,"");
    MessageBox(1500166,"");
  end;
  return;
end;
